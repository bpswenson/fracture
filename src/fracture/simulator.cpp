#include "simulator.hpp"

#include <iostream>
#include <cstring>
#include <dlfcn.h>  // For dynamic loading
/*
void* Simulator::loadReverseHandler(const char* handlerName, const char* libPath) {
    // Load the shared library
    void *handle = dlopen(libPath, RTLD_NOW);
    if (!handle) {
        std::cerr << "Error: Could not load library: " << dlerror() << std::endl;
        return nullptr;
    }

    // Construct the reverse handler name by prefixing "__undo_"
    std::string reverseHandlerName = std::string("__undo_") + handlerName;

    // Find the reverse handler function
    void* reverseHandler = dlsym(handle, reverseHandlerName.c_str());
    if (!reverseHandler) {
        std::cerr << "Error: Could not find reverse handler for " << handlerName << ": " << dlerror() << std::endl;
    }

    return reverseHandler;
}

void* findGeneratedReverseHandler(const std::string& reverseFunctionName) {
    std::string mangledName = "__undo_" + reverseFunctionName;
    void *handler = dlsym(RTLD_DEFAULT, mangledName.c_str());
    if (!handler) {
        std::cerr << "Could not find reverse handler: " << mangledName << std::endl;
    } else {
        std::cout << "Reverse handler found: " << mangledName << std::endl;
    }
    return handler;
}


void Simulator::scheduleEvent(double timestamp, void (*handler)(void*), const std::string &reverseFunctionName, void *data) {
    // Debugging: Print reverse function name
    std::cout << "Scheduling event: " << reverseFunctionName << std::endl;

    // Find the reverse handler generated by the LLVM pass
    auto reverseHandler = reinterpret_cast<void(*)(void*)>(findGeneratedReverseHandler(reverseFunctionName));
    if (!reverseHandler) {
        std::cerr << "Reverse handler not found!" << std::endl;
        return;
    }

    Event event = {timestamp, handler, reverseHandler, data};
    eventQueue.push(event);
}

void Simulator::run(double endTime) {
    while (!eventQueue.empty() && eventQueue.top().timestamp <= endTime) {
        Event event = eventQueue.top();
        eventQueue.pop();

        // Execute the forward event
        std::cout << "Executing handler at time: " << event.timestamp << std::endl;
        event.handler(event.data);
        executedEvents.push(event);
    }
}

void Simulator::rollback(double rollbackTime) {
    while (!executedEvents.empty() && executedEvents.top().timestamp > rollbackTime) {
        Event event = executedEvents.top();
        executedEvents.pop();

        // Execute the reverse event to undo the changes
        if (event.reverseHandler) {
            std::cout << "Executing reverse handler at time: " << event.timestamp << std::endl;
            event.reverseHandler(event.data);
        }
    }
}
*/